# QR 码解码器：从像素到文本

by claude

## QR 码的结构

在讲解码流程之前，先了解一下 QR 码的"地图"——每个黑白小方块（称为"模块"）都有明确的分工。

### 版本与尺寸

QR 码有 40 个版本。版本 V 的尺寸为 (4V+17)×(4V+17) 个模块。例如版本 1 是 21×21，版本 6 是 41×41，版本 7 是 45×45。版本越高，能编码的数据越多。

### 功能图案

QR 码中大约有一半的模块是"功能图案"，它们不承载数据，而是帮助扫描器定位和校准：

```
┌─────────┬─────────────────────────┬─────────┐
│ ■■■■■■■ │                         │ ■■■■■■■ │
│ ■□□□□□■ │      （定时图案横穿）      │ ■□□□□□■ │
│ ■□■■■□■ │ ←─── 第6行交替黑白 ───→  │ ■□■■■□■ │
│ ■□■■■□■ │                         │ ■□■■■□■ │
│ ■□■■■□■ │                         │ ■□■■■□■ │
│ ■□□□□□■ │                         │ ■□□□□□■ │
│ ■■■■■■■ │                         │ ■■■■■■■ │
│ □□□□□□□□│                         │□□□□□□□□ │
│ 格式信息 │     数据 + 纠错区域       │ 格式信息 │
│         │                         │         │
│  ↕第6列  │     ■■■                 │         │
│  交替    │     ■□■  ← 对齐图案      │         │
│  黑白    │     ■■■                 │         │
│         │                         │         │
├─────────┤                         │         │
│ □□□□□□□□│                         │         │
│ ■■■■■■■ │                         │         │
│ ■□□□□□■ │                         │         │
│ ■□■■■□■ │                         │         │
│ ■□■■■□■ │                         │         │
│ ■□■■■□■ │                         │         │
│ ■□□□□□■ │                         │         │
│ ■■■■■■■ │                         │         │
└─────────┴─────────────────────────┴─────────┘
```

- **定位图案 (Finder Pattern)**：左上、右上、左下三个角各一个，7×7 的"回"字形。无论 QR 码怎么旋转，扫描器都能靠它找到码的位置和方向。

- **分隔符 (Separator)**：定位图案外圈的一圈白色模块（宽度 1），防止定位图案和数据区域混淆。

- **定时图案 (Timing Pattern)**：第 6 行和第 6 列上交替出现的黑白条纹。它告诉扫描器模块的精确间距，类似一把"尺子"。

- **对齐图案 (Alignment Pattern)**：版本 2 及以上才有的 5×5 小方块，分布在 QR 码的固定网格位置上。版本越高，对齐图案越多（版本 7 有 6 个，版本 40 有 46 个）。它们帮助校正大尺寸 QR 码的非线性变形。

- **格式信息 (Format Info)**：紧挨左上定位图案的 15 个模块，记录了纠错等级（L/M/Q/H）和掩码编号（0~7）。这 15 比特经过 BCH 编码并异或一个固定值。

- **版本信息 (Version Info)**：版本 7 及以上才有，位于右上和左下定位图案旁的 6×3 区域，记录版本号（经 BCH 编码）。

- **暗模块 (Dark Module)**：坐标 (size-8, 8) 处固定为黑色的单个模块，属于规范的一部分。

### 数据区域与遍历顺序

除去上述功能图案，剩下的模块全部用于承载数据（包括纠错码字）。

数据的读取顺序是一种"牛耕式" (boustrophedon) 的 Z 字形遍历：

1. 从最右边两列开始，自下而上扫描
2. 到顶后左移两列，自上而下扫描
3. 如此交替，遇到第 6 列（定时图案）则跳过
4. 在每一行内，先读右列、再读左列

为什么是两列一组？因为一个码字是 8 比特。两列一组时，每行贡献 2 比特，4 行正好凑满一个码字。如果只用一列，需要 8 行才能凑满，码字在物理上拉得太长，一条横向划痕就可能同时破坏很多码字；如果用四列，2 行就凑满一个码字，但列太宽，码字之间的交织会变少，纠错的分散效果变差。两列是紧凑性和分散性之间的平衡点。

为什么要交替上下（牛耕式）？因为这是最自然的连续遍历——读完一组到顶后直接掉头往下，不需要跳回底部。如果每次都跳回同一端重新扫描，跳转处前后两个比特在物理上隔了整个 QR 码的高度，一旦那个区域有损坏就会同时丢失两个不相邻码字的比特。牛耕式保证了扫描路径始终连续，相邻比特在物理位置上也相邻。

### 纠错等级

QR 码提供四个纠错等级：

| 等级 | 冗余占比 | 可纠正数据损失 |
|------|---------|--------------|
| L    | ~7%     | ~7%          |
| M    | ~15%    | ~15%         |
| Q    | ~25%    | ~25%         |
| H    | ~30%    | ~30%         |

等级越高，可容忍的污损越多，但同尺寸下能编码的数据越少。中央放 Logo 的 QR 码通常选 H 或 Q 级，因为 Logo 遮挡的区域需要靠纠错来恢复。

---

## 概述

`qr_decode.py` 是一个纯 Python 实现的 QR 码解码器（不依赖 pyzbar 等现成解码库）。整个流程可以分为六步：**定位 → 透视校正 → 采样 → 去掩码 → 纠错 → 解码**。

## 第一步：寻找定位图案 (Finder Patterns)

每个 QR 码的三个角上各有一个"回"字形定位图案——三层嵌套的正方形（黑-白-黑），比例为 1:1:3:1:1。

代码的做法是：

1. 对图像做自适应二值化，然后用 OpenCV 的 `findContours` 提取所有轮廓及其层级关系
2. 筛选出近似正方形的轮廓（四边形、宽高比接近 1:1）
3. 将**中心点距离很近的正方形**归为一组——同心嵌套的多个正方形就是一个定位图案
4. 验证最大与最小正方形的面积比在合理范围内（2~25倍）

找到三个定位图案后，还需要判断哪个是左上角 (TL)、右上角 (TR)、左下角 (BL)。方法是：三个点中，距离另外两个点之和最小的那个是左上角（因为它在直角顶点处），然后用叉积判断剩下两个的左右关系。

## 第二步：透视校正 (Perspective Warp)

拍照得到的 QR 码往往有透视变形。要把它"拍平"成正方形，需要知道 QR 码在图中的四个角点。

三个定位图案只给了三个角。第四个角（右下角）的估算方法是：

- 利用三个定位图案各自的四个角点（共 12 个点），与它们在 QR 模块坐标系中的理论位置建立对应关系
- 用 `cv2.findHomography` 求解单应矩阵（图像坐标 ↔ 模块坐标）
- 将 QR 码四个外角的模块坐标投影回图像坐标，得到完整的四角

有了四角，`cv2.getPerspectiveTransform` + `cv2.warpPerspective` 就能把 QR 码区域变换成一个正方形图像。最后用 Otsu 阈值二值化，得到清晰的黑白图。

## 第三步：采样模块矩阵 (Matrix Sampling)

QR 码由 N×N 个"模块"（小方块）组成，版本 V 的尺寸为 (4V+17)×(4V+17)。采样就是确定每个模块是黑还是白。

这一步面临一个精度问题：透视校正后的图像并不完美，模块网格可能有微小偏移。代码用**暴力搜索**来找最优采样参数：

1. 粗搜：遍历不同的起始偏移 (ox, oy) 和模块间距 (ms)，对每组参数采样整个矩阵
2. 打分：用三个定位图案的匹配度（与标准 7×7 定位图案逐像素比对）+ 定时图案（第 6 行/列的交替黑白条纹）作为评分
3. 细搜：在粗搜最优解附近进一步微调

同时，代码还会检测图像中的彩色区域（通过 HSV 色彩空间的饱和度通道），用于发现 QR 码中央的 Logo。如果发现高饱和度的集中区域，就将其标记为"擦除区"，后续交给纠错算法处理。

## 第四步：去掩码 (Unmask)

QR 码在编码时会对数据区域施加一个 XOR 掩码，目的是避免出现大面积的纯黑或纯白区域（这会干扰扫描器的定位）。标准定义了 8 种掩码图案（如棋盘格、条纹等）。

使用哪种掩码记录在 QR 码的"格式信息"中——位于左上定位图案旁边的特定位置。代码读取这 15 个比特，异或一个固定掩码 `0b101010000010010` 后，提取出纠错等级和掩码编号。

然后对每个数据模块，根据掩码编号对应的公式判断是否翻转。例如掩码 0 的规则是 `(row + col) % 2 == 0` 时翻转。

## 第五步：Reed-Solomon 纠错

这是整个解码器中最精妙的部分。QR 码的数据被分成若干个"块"，每块包含数据字节和纠错字节。纠错采用 GF(2^8) 上的 Reed-Solomon 编码。

### 码字提取

数据模块按照 Z 字形遍历顺序（从右下角开始，每两列为一组，交替上下扫描），每 8 个比特组成一个码字。遍历时会跳过所有功能图案（定位、对齐、定时、格式/版本信息）。

### 码字去交织

QR 码将多个块的码字交织存储（类似洗牌）。解码时需要还原：先按列优先顺序将数据码字分配回各块，再将纠错码字分配回各块。

### 纠错解码

每个块独立做 RS 解码：

1. **计算伴随式 (Syndromes)**：将码字多项式在 GF(2^8) 的生成元幂次处求值。全零说明无错
2. **Berlekamp-Massey 算法**：从伴随式求解错误定位多项式 Λ(x)
3. **Chien 搜索**：遍历所有可能位置，找到 Λ(x) 的根，即错误位置
4. **Forney 算法**：利用错误求值多项式 Ω(x) 和 Λ'(x)（形式导数）计算每个错误位置的错误值

对于中央有 Logo 的 QR 码，被 Logo 覆盖的模块位置是已知的——这就是"擦除 (erasure)"。RS 码纠正一个擦除只消耗 1 个符号的冗余（而纠正一个未知位置的错误需要 2 个）。代码通过 Forney 伴随式将擦除和错误分开处理，最大化纠错能力。

## 第六步：数据解码

纠错后的数据字节是一个比特流，按照 QR 码的编码规则解析：

1. 读 4 比特**模式指示符**：0001=数字、0010=字母数字、0100=字节、1000=汉字、0000=终止
2. 读**字符计数**（长度取决于版本和模式）
3. 按模式解码对应数量的字符

例如字节模式就是每 8 比特一个字节，最后用 UTF-8 解码成文本。数字模式则是每 10 比特编码 3 个数字（效率更高）。一个 QR 码可以包含多个模式段，依次拼接即可。

## 小结

从一张可能有透视变形、带 Logo、带彩色背景的照片，到最终解出文本，整个流程是：

```
原图 → 定位图案检测 → 透视校正 → 模块采样 → Logo 擦除标记
     → 去掩码 → 码字提取 → 去交织 → RS 纠错 → 比特流解码 → 文本
```

其中计算量最大的是模块采样的参数搜索，最精妙的是 Reed-Solomon 纠错——它是 QR 码能容忍污损、遮挡甚至 Logo 覆盖的数学基础。
